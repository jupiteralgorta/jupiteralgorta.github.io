<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Test | Jupiter Algorta </title> <meta name="author" content="Jupiter Algorta"> <meta name="description" content="A page test"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jupiteralgorta.github.io/projects/2_project/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Jupiter</span> Algorta </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">Home </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/aboutme/">About me </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">Projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Test</h1> <p class="post-description">A page test</p> </header> <article> <h1 id="introduction">Introduction</h1> <p>Advancing our understanding of cellular behaviour is pivotal in various scientific domains, ranging from fundamental biology to applications in medicine and tissue engineering. At UBC, my research focuses on modelling cell behaviour using the established Cellular Potts Model (CPM) formalism. The Morpheus software group’s efforts have been instrumental, enabling us to delve deeply into the biological intricacies of cellular behaviour, with our emphasis on the biological model itself rather than the framework.</p> <p>This project aims to address a specific facet of cellular dynamics by proposing a novel approach—an individual cell model structured with springs and stimulated to protrude in a predefined direction guided by a Partial Differential Equation (PDE). Such a focus allows for a more nuanced exploration of the challenges inherent in creating computational models that mirror the complex behaviour of individual cells and discovering clever solutions using simple mathematical tools.</p> <h1 id="development">Development</h1> <p>Throughout all stages of this project, the foundation is built upon the formalism of the linear spring-mass model. Before delving into the development, we will discuss how I implemented the model and some of the characteristics of the parameters. The cell membrane will be represented through point-mass objects connected by springs, defined for points \(i\) and \(j\) as follows: \(\begin{aligned} \delta_{ij} &amp;= \frac{(x_i-x_j)}{\| x_i-x_j\|}\cdot(\frac{dx_i}{dt} - \frac{dxj}{dt})\\ m_i\frac{d^2 x_i}{dt^2} &amp;= -\frac{(x_i-x_j)}{\| x_i-x_j\|}[(k(\| x_i-x_j\| - r_{ss})+c\delta_{ij}] \\ \end{aligned}\) Here, \(x_i\) and \(x_j\) are vectors in \(\mathbf{R}^2\), \(m_i\) represents the mass of object \(i\), \(k\) denotes the spring constant, \(c\) is the damping coefficient, and \(r_{ss}\) is the equilibrium length of the spring. To apply the numerical method solvers discussed in class, I converted this system into a first-order system: \(\begin{aligned} \delta_{ij} &amp;= \frac{(x_i-x_j)}{\| x_i-x_j\|}\cdot(v_j - v_i)\\ \frac{d x_i}{dt} &amp;= v_i\\ \frac{d v_i}{dt} &amp;= \frac{-1}{m_i}\frac{(x_i-x_j)}{\| x_i-x_j\|}[k(\| x_i-x_j\| - r_{ss}) +c\delta_{ij}] \end{aligned}\) Another crucial addition to the basics of this model was the incorporation of a center point mass. The significance of this central point is twofold: it prevents the cell from collapsing its volume and becoming a straight line, while also introducing the concept of internal cell pressure. The mass of this central node is set to be the sum of all other nodes’ masses. The springs connecting the center point to the outer ones have their own constants and equilibrium sizes, as they serve different functions than those mimicking the cell’s membrane. The challenge of volume collapse leads us to one of the major problems I had to overcome with this model—tangling and collision of the springs.</p> <h2 id="collision">Collision</h2> <p>The system begins to collapse in undesired and unrealistic ways when one of the point masses passes through a spring. Here is a brief schematic illustrating how this occurs:</p> <figure id="col"> <figure> <img src="collision_tn.jpeg"> </figure> <figure> <img src="collision_tn1.jpeg"> </figure> <figcaption>Here the purple point-mass crosses the spring connecting the red and blue dot</figcaption> </figure> <p>To address this issue, I need to develop a function that can perform two tasks: identify collisions and resolve them.</p> <h3 id="potential-collisions">Potential Collisions</h3> <p>Firstly, the code must identify potential collisions before they occur, allowing us to compare frames and detect collisions. Computing all point masses against every outer spring can be computationally expensive, especially with a high number of point masses. To mitigate this, each point is checked to determine if it lies within the smallest rectangle that the spring occupies.</p> <p>Consider a spring connecting points \(i\) and \(j\) with positions \((x_i, y_i)\) and \((x_j, y_j)\). Without loss of generality, let \(x_i &lt; x_j\) and \(y_i &lt; y_j\). Then, a point \(k\) is considered for collision checking with the spring connecting \(i\) and \(j\) if \(x_i &lt; x_k &lt; x_j\) and \(y_i &lt; y_k &lt; y_j\).</p> <h3 id="identifying-collisions">Identifying Collisions</h3> <p>After storing the points of potential collisions, a collision checker must traverse through two points in time (previous and current) and return a Boolean variable indicating whether a collision occurred. Since this problem is not continuous, we need an algorithm that can gather information from both frames and compare them. To achieve this, I will compute a coordinate change on both frames, bringing the \(x\)-axis to the spring (\(x'\)), and the \(y\)-axis will be the normal vector of the spring (\(y'\)). The matrix for such coordinate change in the frame number \(n\) is given as follows: \(\begin{aligned} A_n&amp;=\begin{bmatrix} x_j-x_i &amp; -(y_j-y_i) \\ y_j-y_i &amp; x_j-x_i \end{bmatrix} \end{aligned}\)</p> <p>One may observe that this is essentially a rotation matrix. Although simplifications can be made to express the matrix in terms of the angle that the spring makes, I opted not to pursue this approach due to the additional computation it would entail.</p> <p>It’s important to note that as the spring itself is in motion, the rotation matrix will also vary from frame to frame. With this coordinate change setup, we can transform the coordinates of the potential collision. A collision is detected when the new y-coordinate changes sign.</p> <figure id="col1"> <figure> <img src="collision_tn_co.jpeg"> </figure> <figure> <img src="collision_tn1_co.jpeg"> </figure> <figcaption>The same collision as discussed in <a href="#col" data-reference-type="ref+label" data-reference="col">1</a> is presented here, along with a representation of the new axis after the coordinate change. This visualization helps illustrate why a shift in the sign of the new <span class="math inline"><em>y</em></span> coordinate would signify a collision—indicating a crossing of the new <span class="math inline"><em>x</em></span>-axis, which corresponds to the spring.</figcaption> </figure> <h3 id="collision-solver">Collision Solver</h3> <p>In this section, I will employ the concept of continuous collision to simulate a perfect elastic collision between the point mass and the spring. An assumption is made that the spring has infinite mass compared to the point mass, treating the spring as if it were a wall.</p> <p>The underlying idea of this algorithm is that upon confirming a collision between frames \(n\) and \(n+1\), we can generate a parameterized curve from the position of point \(k\) in frame \(n\)—denoted as \(p_k(n)\)—to its position in the subsequent frame. This curve is expressed in another variable \(s\), where \(s \in [0,1]\), defined as follows:</p> \[\begin{aligned} u(s) &amp;= [p_k(n+1)]s + [p_k(n)](1-s) \end{aligned}\] <figure id="colcts"> <figure> <img src="collisioncts.jpeg"> </figure> <figcaption>Continuous collision</figcaption> </figure> <p>Now, considering that the point will rebound from the spring, in the spring coordinate system, this corresponds to a change of sign for the new \(y\)-axis. Since there is also a shift in velocity, we will take the change in velocity into account as well, denoted as \(v_k(n)\). In the spring coordinate system, \(p_k(n+1)\) becomes: \(\begin{aligned} (A_{n+1})^{-1}p_k(n+1) &amp;= \left[\begin{array}{rr} -\frac{\left(-x_{j}+x_{i}\right) x_{k}\! \left(n+1\right)}{x_{i}^{2}-2 x_{j} x_{i}+x_{j}^{2}+y_{i}^{2}-2 y_{j} y_{i}+y_{j}^{2}}-\frac{\left(-y_{j}+y_{i}\right) y_{k}\! \left(n+1\right)}{x_{i}^{2}-2 x_{j} x_{i}+x_{j}^{2}+y_{i}^{2}-2 y_{j} y_{i}+y_{j}^{2}} \\ \frac{\left(-y_{j}+y_{i}\right) x_{k}\! \left(n+1\right)}{x_{i}^{2}-2 x_{j} x_{i}+x_{j}^{2}+y_{i}^{2}-2 y_{j} y_{i}+y_{j}^{2}}-\frac{\left(-x_{j}+x_{i}\right) y_{k}\! \left(n+1\right)}{x_{i}^{2}-2 x_{j} x_{i}+x_{j}^{2}+y_{i}^{2}-2 y_{j} y_{i}+y_{j}^{2}} \\ \end{array} \right] \\ \end{aligned}\) Therefore, to compute the new position – \(p'_k(n+1)\) – we will do: \(\begin{aligned} p'_k(n+1) &amp;= (A_{n+1})\begin{bmatrix} -\frac{\left(-x_{j}+x_{i}\right) x_{k}\left(n+1\right)}{x_{i}^{2}-2 x_{j} x_{i}+x_{j}^{2}+y_{i}^{2}-2 y_{j} y_{i}+y_{j}^{2}}-\frac{\left(-y_{j}+y_{i}\right) y_{k}\left(n+1\right)}{x_{i}^{2}-2 x_{j} x_{i}+x_{j}^{2}+y_{i}^{2}-2 y_{j} y_{i}+y_{j}^{2}} \\ -\frac{\left(-y_{j}+y_{i}\right) x_{k}\left(n+1\right)}{x_{i}^{2}-2 x_{j} x_{i}+x_{j}^{2}+y_{i}^{2}-2 y_{j} y_{i}+y_{j}^{2}}+\frac{\left(-x_{j}+x_{i}\right) y_{k}\left(n+1\right)}{x_{i}^{2}-2 x_{j} x_{i}+x_{j}^{2}+y_{i}^{2}-2 y_{j} y_{i}+y_{j}^{2}} \\ \end{bmatrix} \\ \\ \end{aligned}\) Use the above as the new position and velocity for the point \(k\) and continue with the simulation.</p> <figure id="res1"> <figure> <img src="prototype1.jpg"> </figure> <figure> <img src="prototype2.jpg"> </figure> <figcaption>Results of the implementation are presented above. In these simulations, I balanced the perimeter and volume of the cell, creating configurations resembling a circle with radii of 4 (left) and 6 (right). As the cell lacks protrusions, it maintains a circular shape and remains relatively stationary. The visualization of the springs is courtesy of Xue-She Wang (2023), and the code can be found at <a href="https://github.com/wangxueshe/Plot-2D-Spring-in-Matlab" class="uri" rel="external nofollow noopener" target="_blank">https://github.com/wangxueshe/Plot-2D-Spring-in-Matlab</a>.</figcaption> </figure> <h1 id="rac-based-protrusion">Rac-Based Protrusion</h1> <p>The model central to my research revolves around the Rac-based protrusion of white blood cells. Rac is a protein that functions akin to a switch inside the cell. When in the "on" state, it is activated and binds to the cell’s membrane, exhibiting a low diffusion rate. In its inactive state, Rac freely moves within the cell’s cytoplasm, suggesting a high diffusion rate in its availability around the cell’s membrane. The accumulation of active Rac in local high-density regions is sustained through a positive feedback loop. Simultaneously, it produces a local inhibitor, which operates on a much slower time scale and diffusion rate.</p> <p>Under normal circumstances, Rac activation is facilitated by a chemical gradient left by bacteria. Upon activation and binding to the cell membrane, Rac promotes cellular protrusion, aiding white blood cells in moving toward bacteria. However, quantifying these experiments in a laboratory setting poses challenges, prompting the collaborative efforts of Orion Weiner and Jason Town from UCSF, now partners in our research group. They successfully modified white blood cells to respond to light stimulation, allowing them to gather quantitative data on Rac production.</p> <p>The partial differential equation (PDE) model that encapsulates their experiments is defined in periodic boundaries around the cell membrane in 1D:</p> \[\begin{aligned} \frac{\partial A}{\partial t} &amp;= B\left(k_0 + 0.2U + \gamma \frac{A^n}{K^n + A^n}\right) - \left(\delta+0.4H\right) A + D_A \frac{\partial ^2A}{\partial x^2} \\ \frac{\partial B}{\partial t} &amp;= -B\left(k_0 + 0.2U + \gamma \frac{A^n}{K^n + A^n}\right) + \left(\delta+0.4H\right) A + D_A \frac{\partial ^2A}{\partial x^2} \\ \frac{\partial H}{\partial t} &amp;= \epsilon\left(\alpha A - \delta_h H \right)+ D_H \frac{\partial ^2H}{\partial x^2} \\ \end{aligned}\] <p><strong>Variable - \(A\):</strong> Active form of the protein around the membrane. Initialized with random values. Its diffusion rate is low to promote wave-pinning behaviour. Initiated as \(1.5 +\) rand_uni\((-0.1,0.1)\) across space.</p> <p><strong>Variable - \(B\):</strong> Inactive form of the protein around the membrane. Has a higher diffusion rate than A. Acts as a global inhibitor. Initiated as \(0.8\) across space.</p> <p><strong>Variable - \(U\):</strong> The light stimulus around the cell. Initialized at 0, and it changes to 0.05 in specified regions of the 1-d space.</p> <p><strong>Variable - \(H\):</strong> Local Rac inhibitor, slow time scale and low diffusion rate. Initiated as 0</p> <p><strong>Constant - \(k_0:\)</strong> Basal activation of the protein. Value = \(0.067\).</p> <p><strong>Constant - \(\gamma:\)</strong> Rate of positive feedback of active protein. Value = \(1\).</p> <p><strong>Constant - \(\epsilon:\)</strong> Time scale ratio between Rac’s dynamic and the local Rac inhibitor. Value = \(0.05\).</p> <p><strong>Constant - \(\delta:\)</strong> Basal inactivation of the protein. Value = \(1\).</p> <p><strong>Constant - \(\delta_H:\)</strong> Basal decay of the local Rac inhibitor. Value = \(0.4\).</p> <p><strong>Constant - \(\alpha:\)</strong> Activation of local inhibitor promoted by active protein. Value = \(0.1\).</p> <p><strong>Constant - \(K:\)</strong> Threshold for positive feedback for wave pinning. Value = \(1\).</p> <p><strong>Constant - \(n:\)</strong> Hill function coefficient. Value = \(2\).</p> <p><strong>Constant - \(D_A:\)</strong> Diffusion rate of active protein. Value = \(0.05*\left(\frac{3}{2\pi}\right)^2\).</p> <p><strong>Constant - \(D_B:\)</strong> Diffusion rate of inactive protein. Value = \(10*\left(\frac{3}{2\pi}\right)^2\).</p> <p><strong>Constant - \(D_H:\)</strong> Diffusion rate of local inhibitor. Value = \(0.001*\left(\frac{3}{2\pi}\right)^2\).<br> With periodic boundaries, the anticipated outcome is the generation of travelling wave solutions. However, the introduction of a local light stimulus allows us to trap that moving wave. The term \(\left(\frac{3}{2\pi}\right)^2\) serves as a space-scaling factor to align with the parameter regime I work with, yielding comparable results.</p> <figure id="morpheus"> <figure> <img src="morpheus.png"> </figure> <figcaption>Example of simulation ran in Morpheus inside a CPM. <span class="math inline"><em>x</em> ∈ [0,2<em>π</em>]</span> represents the space around the cell’s membrane</figcaption> </figure> <h1 id="implementation-of-pde">Implementation of PDE</h1> <p>The concept is to run the partial differential equation (PDE) in a unit circle centred at the cell. I define the center as the average of all outer point positions and then project the PDE values onto the outer point-mass objects. If a certain threshold is met, that node protrudes outward in proportion to the active protein. Since, in this model, the cell’s state (size, shape, velocity) does not affect the protein dynamics, I precompute the PDE results and use them while solving the spring-mass ordinary differential equation (ODE) system.</p> <h2 id="method-of-lines">Method of Lines</h2> <p>To rephrase this problem in a format convenient for the methods learned or mentioned, I discretize space into equispaced points (\(N\) = 100) and maintain all variables as a single vector named \(R\). This yields the following method of lines:</p> \[\begin{aligned} \frac{d}{dt}R &amp;= f(R) + \frac{D}{h^2}R \\ R = \left[\begin{array}{rrrrrrrrrrrr} A_1\\ A_2 \\ \vdots \\ A_N \\ B_1\\ B_2\\ \vdots \\ B_N \\ H_1 \\ H_2 \\ \vdots \\ H_N \end{array}\right] , f(R) &amp;= \left[\begin{array}{rrrrrrrrrrrr} B_1\left(k_0 + 0.2U_1 + \gamma \frac{A_1^n}{K^n + A_1^n}\right) - \left(\delta+0.4H_1\right) A_1\\ B_2\left(k_0 + 0.2U_2 + \gamma \frac{A_2^n}{K^n + A_2^n}\right) - \left(\delta+0.4H_2\right) A_2\\ \vdots \\ B_N\left(k_0 + 0.2U_N + \gamma \frac{A_N^n}{K^n + A_N^n}\right) - \left(\delta+0.4H_N\right) A_N\\ -B_1\left(k_0 + 0.2U_1 + \gamma \frac{A_1^n}{K^n + A_1^n}\right) + \left(\delta+0.4H_1\right) A_1\\ -B_2\left(k_0 + 0.2U_2 + \gamma \frac{A_2^n}{K^n + A_2^n}\right) + \left(\delta+0.4H_2\right) A_2\\ \vdots \\ -B_N\left(k_0 + 0.2U_N + \gamma \frac{A_N^n}{K^n + A_N^n}\right) + \left(\delta+0.4H_N\right) A_N\\ \epsilon\left(\alpha A_1 - \delta_h H_1 \right) \\ \epsilon\left(\alpha A_2 - \delta_h H_2 \right) \\ \vdots \\ \epsilon\left(\alpha A_N - \delta_h H_N \right) \end{array}\right] \\ L = \left[ \begin{array}{ccccc} -2 &amp; 1 &amp; 0 &amp; \dots &amp; 1 \\ 1 &amp; -2 &amp; 1 &amp; \dots &amp; 0 \\ 0 &amp; 1 &amp; -2 &amp; \dots &amp; 0 \\ \vdots &amp; \vdots &amp; &amp; \vdots &amp;\vdots \\ 1 &amp; 0 &amp; \dots &amp; 1 &amp; -2 \end{array} \right], D &amp;= \left[ \begin{array}{ccc} D_AL &amp; &amp; \makebox(0,0){\text{\huge 0}}\\ &amp;D_BL &amp; \\ \makebox(0,0){\text{\huge 0}}&amp; &amp;D_H L \end{array}\right] \end{aligned}\] <h2 id="sbdf-2">SBDF-2</h2> <p>To obtain an approximate solution \(R(t)\), we will employ the SBDF-2 method, as it has been recommended for reaction-diffusion models, and this problem bears resemblance to such models. For a single time step, we get:</p> <p>\(\begin{aligned} R^{n+1} = \frac{4}{3}R^n-\frac{1}{3}R^{n-1}+\frac{2\Delta t}{3}\left(\frac{D}{h^2} \right)R^{n+1}+\frac{4\Delta t}{3}f(R^n)-\frac{2\Delta t}{3}f(R^{n-1}) \end{aligned}\) Which simplifies to: \(\begin{aligned} R^{n+1} = \left(I_{3N}-\frac{2\Delta t}{3}\left(\frac{D}{h^2} \right)\right)^{-1}\left[\frac{4}{3}R^n-\frac{1}{3}R^{n-1}+\frac{4\Delta t}{3}f(R^n)-\frac{2\Delta t}{3}f(R^{n-1})\right] \end{aligned}\) Since this problem relies on having an initial condition and a step after it, I will use forward Euler to get this extra step. \(\begin{aligned} R^1 = R^0 + \Delta t \left(f(R^0) + \frac{D}{h^2}R^0\right) \end{aligned}\)</p> <figure id="morpheus"> <figure> <img src="PDEexampl.jpg"> </figure> <figcaption>Results of the above implementation in Matlab with <span class="math inline">$$h = \frac{2\pi}{N}$$</span> and <span class="math inline"><em>Δ</em><em>t</em> = <em>h</em><sup>2</sup></span> for <span class="math inline"><em>t</em> ∈ [0,500]</span> which will be still scaled to match the time-scale of the cell model.</figcaption> </figure> <p>Now, armed with data on how the partial differential equation (PDE) dynamics evolve, we need to derive an algorithm to assign the PDE values to the nodes at the cell’s membrane and the center node. This implementation will be integrated into the code governing the spring-mass system, where Rac promotes protrusions, acting as a velocity vector.</p> <h2 id="time-scaling-and-projection">Time Scaling and Projection</h2> <p>Given that the PDE operates on a different time scale than the spring-mass system, a uniform mapping was performed to align the end of the simulation with the end of the Rac data.</p> <p>Within the spring-mass system, we assume that Rac influences the rate of change of position, essentially acting as a velocity vector. To map the locations of the outer nodes to the PDE space, we first determine the center of the cell by averaging the locations of all nodes (excluding the center node) and denote them as \(x_c\) and \(y_c\). After shifting the center to the origin, we compute the \(\theta\) value of each node’s position.</p> <p>To map their \(\theta\) to the PDE space \(x\), we calculate what index of \(x\) produces the \(min(x - \theta)\). Subtracting \(\theta\) element-wise from \(x\), the minimum value serves as the best approximation for \(\theta\) in \(x\), similar to how real numbers are mapped to floating-point representations. Now we can extract the relevant PDE data for each node.</p> <h2 id="protrusion-vector-field">Protrusion Vector Field</h2> <p>The core concept behind the protrusion is to function like air pressure in a balloon—an outward force radiating from the center towards the periphery. Unlike air pressure, this force is more robust, or active, in regions with high Rac activation. The vector field is expressed as follows:</p> \[\begin{aligned} P &amp;= \left[\begin{array}{rr} -1.5 R(\theta)*(R(\theta)&gt;0.4)*\frac{x-x_c}{\sqrt{(x - x_c)^2+(y - y_c)^2}} \\ -1.5 R(\theta)*(R(\theta)&gt;0.4)*\frac{y-y_c}{\sqrt{(x - x_c)^2+(y - y_c)^2}} \end{array} \right] \end{aligned}\] <p>Here, we leverage the Boolean function \((R(\theta)&gt;0.4)\) to construct a piece-wise vector field. This velocity is then integrated into the rate of change of the position of the nodes, inducing protrusion. The center node moves slightly differently to prevent constant changes if the same method is applied.</p> <p>The center node moves in the direction of the outer node with the highest active Rac value, proportionally to the Rac activation in that area.</p> <h1 id="final-results">Final Results</h1> <p>Now, everything is constructed. We have a spring-mass system ensuring connectivity of the cell parts, a collision detector and solver preventing spring entanglement, and finally, a partial differential equation describing the internal mechanisms causing cell protrusion. Putting it all together, we obtain the following:</p> <figure id="final_result"> <figure> <img src="plot201.jpg"> </figure> <figure> <img src="plot251.jpg"> </figure> <figure> <img src="plot301.jpg"> </figure> <figure> <img src="plot351.jpg"> </figure> <figcaption>Apologies for the colloquialism, but this is incredibly exciting! The inner circle, displayed in yellow and blue tones, represents the active Rac data plotted in a circle centred at the cell’s center <span class="math inline">(<em>x</em><sub><em>c</em></sub>,<em>y</em><sub><em>c</em></sub>)</span>. At iteration 250, the light stimuli shift from being around <span class="math inline"><em>π</em>/4</span> to <span class="math inline">3<em>π</em>/4</span>, altering the cell’s movement direction. Fantastic videos illustrating this can be found in the Appendix link, along with all the code.</figcaption> </figure> <h1 id="discussion">Discussion</h1> <p>When comparing these results to my simulations in CPM, we observe qualitatively similar behaviours in terms of protrusion. However, the simplicity of the spring-mass model consistently yields a circular cell shape, regardless of protrusion. I’ve explored adjusting the spring parameters to achieve what we refer to as "aspherity." The aspherity of a given shape quantifies how close it is to a perfect circle by comparing the perimeter to the volume. More malleable cells exhibit "a lot of perimeters for not so much volume," giving them a more liquid-like behaviour. Attempting the same adjustments here results in undesired entanglement, revealing a limitation of the collision solver, particularly when dealing with multiple collisions simultaneously. Perhaps a valuable improvement would be to assign a radius of collision instead of treating nodes as mere points with no area. One of these attempts is depicted below:</p> <figure id="final_result_fail"> <figure> <img src="plot_fail81.jpg"> </figure> <figure> <img src="plot_fail131.jpg"> </figure> <figure> <img src="plot_fail261.jpg"> </figure> <figure> <img src="plot_fail321.jpg"> </figure> <figcaption>Here I used the same parameters as in <a href="#final_result" data-reference-type="ref+Label" data-reference="final_result">7</a>, but I doubled the rest size of the springs in the cell’s membrane</figcaption> </figure> <h1 id="conclusion">Conclusion</h1> <p>As mentioned in the introduction, the primary objective of this project was not to develop a replacement for the formalisms used in my research. Instead, it aimed to illustrate how we continually stand on the shoulders of giants in scientific endeavours. Working with this simplified version has deepened my appreciation for the contributions of the Morpheus development team and enhanced my understanding of the complexities involved in creating a multi-scale model. The code, well-documented and accessible, is provided in the appendix link. Everything presented here was implemented in Matlab; I also tested it in Linux Octave, with the only exception being the video writer feature, which may not work.</p> <h1 id="happy-holidays-happy-holidays-unnumbered">Happy Holidays! {#happy-holidays .unnumbered}</h1> <p>Hi Colin,</p> <p>I wanted to express my gratitude for this incredible course here since we did not have a chance to present the projects. Although I may have been a bit MIA towards the end of the term due to significant opportunities in my research and poor time management on my part, I thoroughly enjoyed and learned a lot from the lectures.</p> <p>Thank you for your guidance and for delivering such an engaging course. I hope you and your family have a wonderful end of the year and a delightful holiday!</p> <h1 id="appendix-appendix-unnumbered">Appendix {#appendix .unnumbered}</h1> <p>The repository for this code can be found at: <a href="https://gitlab.math.ubc.ca/jupitera/jupiter-math607e-project" rel="external nofollow noopener" target="_blank">https://gitlab.math.ubc.ca/jupitera/jupiter-math607e-project</a></p> <p>Here is a brief description of what each script does:</p> <ul> <li> <p><em>runProject_GoodFormat.m</em> - Main "hub" of the simulation, where all the other functions are called, and parameters for springs and the number of nodes are set.</p> </li> <li> <p><em>ode_rk4_center.m</em> - Where the derivatives relate all nodes’ velocity and position. This is the \(f(u)\) function of the RK4 method.</p> </li> <li> <p><em>getLines.m</em> - Gets information from the position and indexation of the nodes and creates objects that contain information about each spring.</p> </li> <li> <p><em>collision.m</em> - Where collisions between nodes and springs are detected and solved.</p> </li> <li> <p><em>plot_cell.m</em> - Plots the simulation and saves a <em>.mp4</em> animation.</p> </li> <li> <p><em>plot_cell_control.m</em> - Used to plot frames while doing debugging and testing. Works similarly to the above, but it has fewer features and is less automated.</p> </li> <li> <p><em>Spring.m</em> - Code developed Xue-She Wang (2023), I found it online through the Matlab website.</p> </li> <li> <p><em>optorac.m</em> - Runs Rac simulation and saves the data. Cannot run this together with the rest without running out of memory.</p> </li> </ul> </article> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"jupiteralgorta/jupiteralgorta.github.io","data-repo-id":"","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Jupiter Algorta. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?da39b660470d1ba6e6b8bf5f37070b6e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>